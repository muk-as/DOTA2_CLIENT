#pragma once
#include "source2sdk/entity2/CEntityIOOutput.hpp"
#include "source2sdk/server/CPointEntity.hpp"
#include "source2sdk/server/SceneOnPlayerDeath_t.hpp"
#include "source2sdk/source2gen.hpp"
#include <cstddef>
#include <cstdint>

// /////////////////////////////////////////////////////////////
// Module: server
// Created using source2gen - github.com/neverlosecc/source2gen
// /////////////////////////////////////////////////////////////

namespace source2sdk::server
{
    class CBaseEntity;
};

namespace source2sdk::server
{
    class CBaseFlex;
};

namespace source2sdk::server
{
    class CSceneListManager;
};

namespace source2sdk::server
{
    // Registered alignment: 0x8
    // Alignment: 0x8
    // Standard-layout class: false
    // Size: 0xa40
    // Has VTable
    // Construct allowed
    // 
    // static metadata: MNetworkVarNames "bool m_bIsPlayingBack"
    // static metadata: MNetworkVarNames "bool m_bPaused"
    // static metadata: MNetworkVarNames "bool m_bMultiplayer"
    // static metadata: MNetworkVarNames "bool m_bAutogenerated"
    // static metadata: MNetworkVarNames "float32 m_flForceClientTime"
    // static metadata: MNetworkVarNames "CHandle< CBaseFlex > m_hActorList"
    // static metadata: MNetworkVarNames "uint16 m_nSceneStringIndex"
    #pragma pack(push, 1)
    class CSceneEntity : public server::CPointEntity
    {
    public:
        [[maybe_unused]] std::uint8_t pad_0x4e0[0x8]; // 0x4e0
        CUtlSymbolLarge m_iszSceneFile; // 0x4e8        
        CUtlSymbolLarge m_iszResumeSceneFile; // 0x4f0        
        CUtlSymbolLarge m_iszTarget1; // 0x4f8        
        CUtlSymbolLarge m_iszTarget2; // 0x500        
        CUtlSymbolLarge m_iszTarget3; // 0x508        
        CUtlSymbolLarge m_iszTarget4; // 0x510        
        CUtlSymbolLarge m_iszTarget5; // 0x518        
        CUtlSymbolLarge m_iszTarget6; // 0x520        
        CUtlSymbolLarge m_iszTarget7; // 0x528        
        CUtlSymbolLarge m_iszTarget8; // 0x530        
        // m_hTarget1 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget1;
        char m_hTarget1[0x4]; // 0x538        
        // m_hTarget2 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget2;
        char m_hTarget2[0x4]; // 0x53c        
        // m_hTarget3 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget3;
        char m_hTarget3[0x4]; // 0x540        
        // m_hTarget4 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget4;
        char m_hTarget4[0x4]; // 0x544        
        // m_hTarget5 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget5;
        char m_hTarget5[0x4]; // 0x548        
        // m_hTarget6 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget6;
        char m_hTarget6[0x4]; // 0x54c        
        // m_hTarget7 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget7;
        char m_hTarget7[0x4]; // 0x550        
        // m_hTarget8 has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hTarget8;
        char m_hTarget8[0x4]; // 0x554        
        CUtlSymbolLarge m_sTargetAttachment; // 0x558        
        // metadata: MNetworkEnable
        bool m_bIsPlayingBack; // 0x560        
        // metadata: MNetworkEnable
        bool m_bPaused; // 0x561        
        // metadata: MNetworkEnable
        bool m_bMultiplayer; // 0x562        
        // metadata: MNetworkEnable
        bool m_bAutogenerated; // 0x563        
        // metadata: MNetworkEnable
        float m_flForceClientTime; // 0x564        
        float m_flCurrentTime; // 0x568        
        float m_flFrameTime; // 0x56c        
        bool m_bCancelAtNextInterrupt; // 0x570        
        [[maybe_unused]] std::uint8_t pad_0x571[0x3]; // 0x571
        float m_fPitch; // 0x574        
        bool m_bAutomated; // 0x578        
        [[maybe_unused]] std::uint8_t pad_0x579[0x3]; // 0x579
        int32_t m_nAutomatedAction; // 0x57c        
        float m_flAutomationDelay; // 0x580        
        float m_flAutomationTime; // 0x584        
        // m_hWaitingForThisResumeScene has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hWaitingForThisResumeScene;
        char m_hWaitingForThisResumeScene[0x4]; // 0x588        
        bool m_bWaitingForResumeScene; // 0x58c        
        bool m_bPausedViaInput; // 0x58d        
        bool m_bPauseAtNextInterrupt; // 0x58e        
        bool m_bWaitingForActor; // 0x58f        
        bool m_bWaitingForInterrupt; // 0x590        
        bool m_bInterruptedActorsScenes; // 0x591        
        bool m_bBreakOnNonIdle; // 0x592        
        bool m_bSceneFinished; // 0x593        
        [[maybe_unused]] std::uint8_t pad_0x594[0x4]; // 0x594
        // metadata: MNetworkEnable
        // m_hActorList has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CNetworkUtlVectorBase<CHandle<server::CBaseFlex>> m_hActorList;
        char m_hActorList[0x18]; // 0x598        
        // m_hRemoveActorList has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CUtlVector<CHandle<server::CBaseEntity>> m_hRemoveActorList;
        char m_hRemoveActorList[0x18]; // 0x5b0        
        [[maybe_unused]] std::uint8_t pad_0x5c8[0x30]; // 0x5c8
        int32_t m_nSceneFlushCounter; // 0x5f8        
        // metadata: MNetworkEnable
        uint16_t m_nSceneStringIndex; // 0x5fc        
        [[maybe_unused]] std::uint8_t pad_0x5fe[0x2]; // 0x5fe
        entity2::CEntityIOOutput m_OnStart; // 0x600        
        entity2::CEntityIOOutput m_OnCompletion; // 0x628        
        entity2::CEntityIOOutput m_OnCanceled; // 0x650        
        entity2::CEntityIOOutput m_OnPaused; // 0x678        
        entity2::CEntityIOOutput m_OnResumed; // 0x6a0        
        entity2::CEntityIOOutput m_OnTrigger[16]; // 0x6c8        
        [[maybe_unused]] std::uint8_t pad_0x948[0x90]; // 0x948
        // m_hInterruptScene has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CSceneEntity> m_hInterruptScene;
        char m_hInterruptScene[0x4]; // 0x9d8        
        int32_t m_nInterruptCount; // 0x9dc        
        bool m_bSceneMissing; // 0x9e0        
        bool m_bInterrupted; // 0x9e1        
        bool m_bCompletedEarly; // 0x9e2        
        bool m_bInterruptSceneFinished; // 0x9e3        
        bool m_bRestoring; // 0x9e4        
        [[maybe_unused]] std::uint8_t pad_0x9e5[0x3]; // 0x9e5
        // m_hNotifySceneCompletion has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CUtlVector<CHandle<server::CSceneEntity>> m_hNotifySceneCompletion;
        char m_hNotifySceneCompletion[0x18]; // 0x9e8        
        // m_hListManagers has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CUtlVector<CHandle<server::CSceneListManager>> m_hListManagers;
        char m_hListManagers[0x18]; // 0xa00        
        CUtlSymbolLarge m_iszSoundName; // 0xa18        
        CUtlSymbolLarge m_iszSequenceName; // 0xa20        
        // m_hActor has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseFlex> m_hActor;
        char m_hActor[0x4]; // 0xa28        
        // m_hActivator has a template type with potentially unknown template parameters. You can try uncommenting the field below.
        // CHandle<server::CBaseEntity> m_hActivator;
        char m_hActivator[0x4]; // 0xa2c        
        int32_t m_BusyActor; // 0xa30        
        server::SceneOnPlayerDeath_t m_iPlayerDeathBehavior; // 0xa34        
        [[maybe_unused]] std::uint8_t pad_0xa38[0x8];
        
        // Static fields:
        static int32_t &Get_s_nSceneFlushCounter() {return *reinterpret_cast<int32_t*>(interfaces::g_schema->FindTypeScopeForModule("server.dll")->FindDeclaredClass("CSceneEntity")->GetStaticFields()[0]->m_pInstance);};
        
        // Datamap fields:
        // void m_pScene; // 0x5f0
        // void m_pRecipientFilter; // 0xa38
        // void InputStartPlayback; // 0x0
        // void InputPausePlayback; // 0x0
        // void InputResumePlayback; // 0x0
        // void InputCancelPlayback; // 0x0
        // void InputCancelAtNextInterrupt; // 0x0
        // float InputPitchShiftPlayback; // 0x0
        // CUtlSymbolLarge InputInterjectResponse; // 0x0
        // void InputStopWaitingForActor; // 0x0
        // int32_t InputTriggerEvent; // 0x0
        // CUtlSymbolLarge InputSetTarget1; // 0x0
        // CUtlSymbolLarge InputSetTarget2; // 0x0
        // void InputScriptPlayerDeath; // 0x0
        // void InputPauseAtNextInterrupt; // 0x0
        // void m_OnTrigger[ 0 ]; // 0x6c8
        // void m_OnTrigger[ 1 ]; // 0x6f0
        // void m_OnTrigger[ 2 ]; // 0x718
        // void m_OnTrigger[ 3 ]; // 0x740
        // void m_OnTrigger[ 4 ]; // 0x768
        // void m_OnTrigger[ 5 ]; // 0x790
        // void m_OnTrigger[ 6 ]; // 0x7b8
        // void m_OnTrigger[ 7 ]; // 0x7e0
        // void m_OnTrigger[ 8 ]; // 0x808
        // void m_OnTrigger[ 9 ]; // 0x830
        // void m_OnTrigger[ 10 ]; // 0x858
        // void m_OnTrigger[ 11 ]; // 0x880
        // void m_OnTrigger[ 12 ]; // 0x8a8
        // void m_OnTrigger[ 13 ]; // 0x8d0
        // void m_OnTrigger[ 14 ]; // 0x8f8
        // void m_OnTrigger[ 15 ]; // 0x920
    };
    #pragma pack(pop)
    
    // Cannot assert offsets of fields in CSceneEntity because it is not a standard-layout class
    static_assert(sizeof(CSceneEntity) == 0xa40);
};
